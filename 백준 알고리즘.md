## Algorithm
***백준 알고리즘 특강을 들은 후 강의를 기반으로 백준 알고리즘 웹페이지의 문제들을 풀면서 해답을 올려놓는 Repository입니다.***

## 백준 알고리즘

1. 시뮬레이션 -> 문제에 써있는 것을 그대로 코드로 구현하는 것
2. 브루트포스(Brute Force) -> 모든 방법을 시도해 보는 것
3. BFS 최단거리 구하기.
4. 다이나믹 프로그래밍 (1,2,3이 더 중요)

## 시간복잡도, 공간복잡도

- 시간 복잡도가 더 중요 공간복잡도는 메모리 측면.
- 알고리즘 문제 -> 시간 제한, 메모리 제한
- 시간복잡도: 입력의 크기에 따라서 얼마나 시간이 걸릴지를 대충 예상 하는 것
- 시간 복잡도는 코드를 작성 하면서 아는법 or 방법론 적으로 접근해서 시간 복잡도를 알아내는 법, 방법을 생각하고 코드를 작성하는게 더 빠른 접근

## 시뮬레이션

1. 주사위 굴리기
	- 기준을 정해서 칸에 번호를 지정
	- 해당 칸 번호가 어떻게 변하는지에 대한 관점
2. 톱니바퀴

## 브루트 포스(Brute Force)
1. 모든 경우의 수를 다해보는 것이니깐 먼저 가능한 경우의 수 계산 해보기
2. 경우의 수가 그렇게 많지 않으면 그걸 어떻게 만들것일까?
3. 2번 방법을 이용해서 어떻게 답을 맞출까

-> 재귀로 많이 푼다.
## 재귀함수 사용하기(함수의 정의가 중요)
1. 정답을 찾은 경우
2. 불가능한 경우
3. 다음 경우 호출

##다이나믹 프로그래밍 으로 풀 수 있는 경우

1. 퇴사 문제 같은 경우 각각의 날짜마다 최댓값을 구하면서 중복(각 날마다 작은값은 버림) 제거 하는거를 다이나믹으로 풀 수 있고 O(N)이 된다. 즉 i라는 날짜에서 부터 보고 그전에서 최댓값만 보는 경우.
2. 앞에 어떤 상황이 놓여져있는지 몰라도 답을 구할 수 있다.
3. 상태를 점화식의 형태로 나타내기
4. ex) N명의 학생이 있을 때 무엇인가를 나눠줄려고 한다. 이 경우는 왼쪽 학생 10명 오른쪽 학생 20명 이런 식으로 각각의 문제를 풀고 합쳐주면 된다.
5. 간단 하게 크기를 나눈다.
6. 모르는 정보는 변수로 두어야 한다.
7. 


## 그래프

1. 최단 경로
   - 출발점으로 다시 돌아오는 경우 -> 더 어렵
   - 그냥 도착만 하는 경우
2. 방향성이 있거나 없거나 루프가 있거나 하는건 문제가 되지 않는다.
3. 가중치가 있는 경우와 없는경우 없는 경우는 그냥 1이라고 생각하기
4. 차수: 정점과 연결되어 있는 간선의 개수
5. 그래프 탐색 목적: 한 시작점부터 모든 정점을 한 번씩 방문

## Breadth First Search (너비 우선 탐색) 

1. 시간복잡도: O(V+E) -> 모든 정점을 한번씩 방문 + 각 정점이 queue에서 나올 때 마다 연결된 간선을 한 번씩 살펴보기 때문에
2. 가중치가 1일 때, 최단 거리를 구하는 알고리즘이다. 만약 모든 가중치가 1이 아니면, 최단 거리를 구할수 없다.
3. 즉 Bfs 로 해결할 수 있는 문제
   - 최소 비용 문제
   - 간선의 가중치가 1
   - 정점과 간선의 개수가 적어야 한다.(1억개를 넘지 않는 v+e 가)
4. 벽 부수고 이동하기
	- 0번 -> (빈칸->빈칸, 빈칸->벽)
	- 1번 -> (빈칸->빈칸, 빈칸->벽(x), 벽->빈칸, 벽->벽(x))
	- 벽0번, 벽1번 둘 다 도착 가능
	- 벽이 없을 때 도착가능
	- 벽을 1번 부술 때 도착가능
	- 도착불가능 





### 코드 플러스 웹사이트 문제도 한번 보기
### 자바로 출력할때 StringBuffer 사용해서 문자열 합쳐서 출력하기 시간 차이가 많이 난다.







## 풀이시 알아야 할 사항

### 다음 순열 찾는 순서

1. A[i-1]<A[i] 를 만족하는 가장 큰 i를 찾는다.
2. j>=i 이면서 A[j]>A[i-1]를 만족하는 가장 큰 j를 찾는다.
3. A[i-1]과 A[j]를 swap한다.
4. A[i]부터 순열을 뒤집는다.

```
boolean next_permutation(int[] a) {
	    int i = a.length-1;
	    while (i > 0 && a[i-1] >= a[i]) {
	        i -= 1;
	    }

	    if (i <= 0) {
	        return false;
	    }

	    int j = a.length-1;
	    while (a[j] <= a[i-1]) {
	        j -= 1;
	    }

	    int temp = a[i-1];
	    a[i-1] = a[j];
	    a[j] = temp;

	    j = a.length-1;
	    while (i < j) {
	        temp = a[i];
	        a[i] = a[j];
	        a[j] = temp;
	        i += 1;
	        j -= 1;
	    }
	    return true;
	}
```






